// Code generated by entc, DO NOT EDIT.

package audit

import (
	"hello/pkg/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// UpdateTime applies equality check predicate on the "update_time" field. It's identical to UpdateTimeEQ.
func UpdateTime(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// URL applies equality check predicate on the "url" field. It's identical to URLEQ.
func URL(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldURL), v))
	})
}

// Query applies equality check predicate on the "query" field. It's identical to QueryEQ.
func Query(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuery), v))
	})
}

// Method applies equality check predicate on the "method" field. It's identical to MethodEQ.
func Method(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMethod), v))
	})
}

// Request applies equality check predicate on the "request" field. It's identical to RequestEQ.
func Request(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRequest), v))
	})
}

// Response applies equality check predicate on the "response" field. It's identical to ResponseEQ.
func Response(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResponse), v))
	})
}

// Header applies equality check predicate on the "header" field. It's identical to HeaderEQ.
func Header(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeader), v))
	})
}

// StatusCode applies equality check predicate on the "status_code" field. It's identical to StatusCodeEQ.
func StatusCode(v int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusCode), v))
	})
}

// RemoteIP applies equality check predicate on the "remote_ip" field. It's identical to RemoteIPEQ.
func RemoteIP(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemoteIP), v))
	})
}

// ClientIP applies equality check predicate on the "client_ip" field. It's identical to ClientIPEQ.
func ClientIP(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClientIP), v))
	})
}

// CostTime applies equality check predicate on the "cost_time" field. It's identical to CostTimeEQ.
func CostTime(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCostTime), v))
	})
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateTime), v))
	})
}

// UpdateTimeEQ applies the EQ predicate on the "update_time" field.
func UpdateTimeEQ(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeNEQ applies the NEQ predicate on the "update_time" field.
func UpdateTimeNEQ(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeIn applies the In predicate on the "update_time" field.
func UpdateTimeIn(vs ...time.Time) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeNotIn applies the NotIn predicate on the "update_time" field.
func UpdateTimeNotIn(vs ...time.Time) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeGT applies the GT predicate on the "update_time" field.
func UpdateTimeGT(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeGTE applies the GTE predicate on the "update_time" field.
func UpdateTimeGTE(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLT applies the LT predicate on the "update_time" field.
func UpdateTimeLT(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLTE applies the LTE predicate on the "update_time" field.
func UpdateTimeLTE(v time.Time) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateTime), v))
	})
}

// URLEQ applies the EQ predicate on the "url" field.
func URLEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldURL), v))
	})
}

// URLNEQ applies the NEQ predicate on the "url" field.
func URLNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldURL), v))
	})
}

// URLIn applies the In predicate on the "url" field.
func URLIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldURL), v...))
	})
}

// URLNotIn applies the NotIn predicate on the "url" field.
func URLNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldURL), v...))
	})
}

// URLGT applies the GT predicate on the "url" field.
func URLGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldURL), v))
	})
}

// URLGTE applies the GTE predicate on the "url" field.
func URLGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldURL), v))
	})
}

// URLLT applies the LT predicate on the "url" field.
func URLLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldURL), v))
	})
}

// URLLTE applies the LTE predicate on the "url" field.
func URLLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldURL), v))
	})
}

// URLContains applies the Contains predicate on the "url" field.
func URLContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldURL), v))
	})
}

// URLHasPrefix applies the HasPrefix predicate on the "url" field.
func URLHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldURL), v))
	})
}

// URLHasSuffix applies the HasSuffix predicate on the "url" field.
func URLHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldURL), v))
	})
}

// URLIsNil applies the IsNil predicate on the "url" field.
func URLIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldURL)))
	})
}

// URLNotNil applies the NotNil predicate on the "url" field.
func URLNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldURL)))
	})
}

// URLEqualFold applies the EqualFold predicate on the "url" field.
func URLEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldURL), v))
	})
}

// URLContainsFold applies the ContainsFold predicate on the "url" field.
func URLContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldURL), v))
	})
}

// QueryEQ applies the EQ predicate on the "query" field.
func QueryEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuery), v))
	})
}

// QueryNEQ applies the NEQ predicate on the "query" field.
func QueryNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldQuery), v))
	})
}

// QueryIn applies the In predicate on the "query" field.
func QueryIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldQuery), v...))
	})
}

// QueryNotIn applies the NotIn predicate on the "query" field.
func QueryNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldQuery), v...))
	})
}

// QueryGT applies the GT predicate on the "query" field.
func QueryGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldQuery), v))
	})
}

// QueryGTE applies the GTE predicate on the "query" field.
func QueryGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldQuery), v))
	})
}

// QueryLT applies the LT predicate on the "query" field.
func QueryLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldQuery), v))
	})
}

// QueryLTE applies the LTE predicate on the "query" field.
func QueryLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldQuery), v))
	})
}

// QueryContains applies the Contains predicate on the "query" field.
func QueryContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldQuery), v))
	})
}

// QueryHasPrefix applies the HasPrefix predicate on the "query" field.
func QueryHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldQuery), v))
	})
}

// QueryHasSuffix applies the HasSuffix predicate on the "query" field.
func QueryHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldQuery), v))
	})
}

// QueryIsNil applies the IsNil predicate on the "query" field.
func QueryIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldQuery)))
	})
}

// QueryNotNil applies the NotNil predicate on the "query" field.
func QueryNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldQuery)))
	})
}

// QueryEqualFold applies the EqualFold predicate on the "query" field.
func QueryEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldQuery), v))
	})
}

// QueryContainsFold applies the ContainsFold predicate on the "query" field.
func QueryContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldQuery), v))
	})
}

// MethodEQ applies the EQ predicate on the "method" field.
func MethodEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMethod), v))
	})
}

// MethodNEQ applies the NEQ predicate on the "method" field.
func MethodNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMethod), v))
	})
}

// MethodIn applies the In predicate on the "method" field.
func MethodIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMethod), v...))
	})
}

// MethodNotIn applies the NotIn predicate on the "method" field.
func MethodNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMethod), v...))
	})
}

// MethodGT applies the GT predicate on the "method" field.
func MethodGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMethod), v))
	})
}

// MethodGTE applies the GTE predicate on the "method" field.
func MethodGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMethod), v))
	})
}

// MethodLT applies the LT predicate on the "method" field.
func MethodLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMethod), v))
	})
}

// MethodLTE applies the LTE predicate on the "method" field.
func MethodLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMethod), v))
	})
}

// MethodContains applies the Contains predicate on the "method" field.
func MethodContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMethod), v))
	})
}

// MethodHasPrefix applies the HasPrefix predicate on the "method" field.
func MethodHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMethod), v))
	})
}

// MethodHasSuffix applies the HasSuffix predicate on the "method" field.
func MethodHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMethod), v))
	})
}

// MethodIsNil applies the IsNil predicate on the "method" field.
func MethodIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMethod)))
	})
}

// MethodNotNil applies the NotNil predicate on the "method" field.
func MethodNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMethod)))
	})
}

// MethodEqualFold applies the EqualFold predicate on the "method" field.
func MethodEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMethod), v))
	})
}

// MethodContainsFold applies the ContainsFold predicate on the "method" field.
func MethodContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMethod), v))
	})
}

// RequestEQ applies the EQ predicate on the "request" field.
func RequestEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRequest), v))
	})
}

// RequestNEQ applies the NEQ predicate on the "request" field.
func RequestNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRequest), v))
	})
}

// RequestIn applies the In predicate on the "request" field.
func RequestIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRequest), v...))
	})
}

// RequestNotIn applies the NotIn predicate on the "request" field.
func RequestNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRequest), v...))
	})
}

// RequestGT applies the GT predicate on the "request" field.
func RequestGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRequest), v))
	})
}

// RequestGTE applies the GTE predicate on the "request" field.
func RequestGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRequest), v))
	})
}

// RequestLT applies the LT predicate on the "request" field.
func RequestLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRequest), v))
	})
}

// RequestLTE applies the LTE predicate on the "request" field.
func RequestLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRequest), v))
	})
}

// RequestContains applies the Contains predicate on the "request" field.
func RequestContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRequest), v))
	})
}

// RequestHasPrefix applies the HasPrefix predicate on the "request" field.
func RequestHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRequest), v))
	})
}

// RequestHasSuffix applies the HasSuffix predicate on the "request" field.
func RequestHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRequest), v))
	})
}

// RequestIsNil applies the IsNil predicate on the "request" field.
func RequestIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRequest)))
	})
}

// RequestNotNil applies the NotNil predicate on the "request" field.
func RequestNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRequest)))
	})
}

// RequestEqualFold applies the EqualFold predicate on the "request" field.
func RequestEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRequest), v))
	})
}

// RequestContainsFold applies the ContainsFold predicate on the "request" field.
func RequestContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRequest), v))
	})
}

// ResponseEQ applies the EQ predicate on the "response" field.
func ResponseEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResponse), v))
	})
}

// ResponseNEQ applies the NEQ predicate on the "response" field.
func ResponseNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldResponse), v))
	})
}

// ResponseIn applies the In predicate on the "response" field.
func ResponseIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldResponse), v...))
	})
}

// ResponseNotIn applies the NotIn predicate on the "response" field.
func ResponseNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldResponse), v...))
	})
}

// ResponseGT applies the GT predicate on the "response" field.
func ResponseGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldResponse), v))
	})
}

// ResponseGTE applies the GTE predicate on the "response" field.
func ResponseGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldResponse), v))
	})
}

// ResponseLT applies the LT predicate on the "response" field.
func ResponseLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldResponse), v))
	})
}

// ResponseLTE applies the LTE predicate on the "response" field.
func ResponseLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldResponse), v))
	})
}

// ResponseContains applies the Contains predicate on the "response" field.
func ResponseContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldResponse), v))
	})
}

// ResponseHasPrefix applies the HasPrefix predicate on the "response" field.
func ResponseHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldResponse), v))
	})
}

// ResponseHasSuffix applies the HasSuffix predicate on the "response" field.
func ResponseHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldResponse), v))
	})
}

// ResponseIsNil applies the IsNil predicate on the "response" field.
func ResponseIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldResponse)))
	})
}

// ResponseNotNil applies the NotNil predicate on the "response" field.
func ResponseNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldResponse)))
	})
}

// ResponseEqualFold applies the EqualFold predicate on the "response" field.
func ResponseEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldResponse), v))
	})
}

// ResponseContainsFold applies the ContainsFold predicate on the "response" field.
func ResponseContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldResponse), v))
	})
}

// HeaderEQ applies the EQ predicate on the "header" field.
func HeaderEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHeader), v))
	})
}

// HeaderNEQ applies the NEQ predicate on the "header" field.
func HeaderNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHeader), v))
	})
}

// HeaderIn applies the In predicate on the "header" field.
func HeaderIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHeader), v...))
	})
}

// HeaderNotIn applies the NotIn predicate on the "header" field.
func HeaderNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHeader), v...))
	})
}

// HeaderGT applies the GT predicate on the "header" field.
func HeaderGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHeader), v))
	})
}

// HeaderGTE applies the GTE predicate on the "header" field.
func HeaderGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHeader), v))
	})
}

// HeaderLT applies the LT predicate on the "header" field.
func HeaderLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHeader), v))
	})
}

// HeaderLTE applies the LTE predicate on the "header" field.
func HeaderLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHeader), v))
	})
}

// HeaderContains applies the Contains predicate on the "header" field.
func HeaderContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHeader), v))
	})
}

// HeaderHasPrefix applies the HasPrefix predicate on the "header" field.
func HeaderHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHeader), v))
	})
}

// HeaderHasSuffix applies the HasSuffix predicate on the "header" field.
func HeaderHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHeader), v))
	})
}

// HeaderIsNil applies the IsNil predicate on the "header" field.
func HeaderIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldHeader)))
	})
}

// HeaderNotNil applies the NotNil predicate on the "header" field.
func HeaderNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldHeader)))
	})
}

// HeaderEqualFold applies the EqualFold predicate on the "header" field.
func HeaderEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHeader), v))
	})
}

// HeaderContainsFold applies the ContainsFold predicate on the "header" field.
func HeaderContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHeader), v))
	})
}

// StatusCodeEQ applies the EQ predicate on the "status_code" field.
func StatusCodeEQ(v int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusCode), v))
	})
}

// StatusCodeNEQ applies the NEQ predicate on the "status_code" field.
func StatusCodeNEQ(v int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatusCode), v))
	})
}

// StatusCodeIn applies the In predicate on the "status_code" field.
func StatusCodeIn(vs ...int) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatusCode), v...))
	})
}

// StatusCodeNotIn applies the NotIn predicate on the "status_code" field.
func StatusCodeNotIn(vs ...int) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatusCode), v...))
	})
}

// StatusCodeGT applies the GT predicate on the "status_code" field.
func StatusCodeGT(v int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStatusCode), v))
	})
}

// StatusCodeGTE applies the GTE predicate on the "status_code" field.
func StatusCodeGTE(v int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStatusCode), v))
	})
}

// StatusCodeLT applies the LT predicate on the "status_code" field.
func StatusCodeLT(v int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStatusCode), v))
	})
}

// StatusCodeLTE applies the LTE predicate on the "status_code" field.
func StatusCodeLTE(v int) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStatusCode), v))
	})
}

// StatusCodeIsNil applies the IsNil predicate on the "status_code" field.
func StatusCodeIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatusCode)))
	})
}

// StatusCodeNotNil applies the NotNil predicate on the "status_code" field.
func StatusCodeNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatusCode)))
	})
}

// RemoteIPEQ applies the EQ predicate on the "remote_ip" field.
func RemoteIPEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPNEQ applies the NEQ predicate on the "remote_ip" field.
func RemoteIPNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPIn applies the In predicate on the "remote_ip" field.
func RemoteIPIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRemoteIP), v...))
	})
}

// RemoteIPNotIn applies the NotIn predicate on the "remote_ip" field.
func RemoteIPNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRemoteIP), v...))
	})
}

// RemoteIPGT applies the GT predicate on the "remote_ip" field.
func RemoteIPGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPGTE applies the GTE predicate on the "remote_ip" field.
func RemoteIPGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPLT applies the LT predicate on the "remote_ip" field.
func RemoteIPLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPLTE applies the LTE predicate on the "remote_ip" field.
func RemoteIPLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPContains applies the Contains predicate on the "remote_ip" field.
func RemoteIPContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPHasPrefix applies the HasPrefix predicate on the "remote_ip" field.
func RemoteIPHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPHasSuffix applies the HasSuffix predicate on the "remote_ip" field.
func RemoteIPHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPIsNil applies the IsNil predicate on the "remote_ip" field.
func RemoteIPIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRemoteIP)))
	})
}

// RemoteIPNotNil applies the NotNil predicate on the "remote_ip" field.
func RemoteIPNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRemoteIP)))
	})
}

// RemoteIPEqualFold applies the EqualFold predicate on the "remote_ip" field.
func RemoteIPEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRemoteIP), v))
	})
}

// RemoteIPContainsFold applies the ContainsFold predicate on the "remote_ip" field.
func RemoteIPContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRemoteIP), v))
	})
}

// ClientIPEQ applies the EQ predicate on the "client_ip" field.
func ClientIPEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClientIP), v))
	})
}

// ClientIPNEQ applies the NEQ predicate on the "client_ip" field.
func ClientIPNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldClientIP), v))
	})
}

// ClientIPIn applies the In predicate on the "client_ip" field.
func ClientIPIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldClientIP), v...))
	})
}

// ClientIPNotIn applies the NotIn predicate on the "client_ip" field.
func ClientIPNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldClientIP), v...))
	})
}

// ClientIPGT applies the GT predicate on the "client_ip" field.
func ClientIPGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldClientIP), v))
	})
}

// ClientIPGTE applies the GTE predicate on the "client_ip" field.
func ClientIPGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldClientIP), v))
	})
}

// ClientIPLT applies the LT predicate on the "client_ip" field.
func ClientIPLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldClientIP), v))
	})
}

// ClientIPLTE applies the LTE predicate on the "client_ip" field.
func ClientIPLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldClientIP), v))
	})
}

// ClientIPContains applies the Contains predicate on the "client_ip" field.
func ClientIPContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldClientIP), v))
	})
}

// ClientIPHasPrefix applies the HasPrefix predicate on the "client_ip" field.
func ClientIPHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldClientIP), v))
	})
}

// ClientIPHasSuffix applies the HasSuffix predicate on the "client_ip" field.
func ClientIPHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldClientIP), v))
	})
}

// ClientIPIsNil applies the IsNil predicate on the "client_ip" field.
func ClientIPIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldClientIP)))
	})
}

// ClientIPNotNil applies the NotNil predicate on the "client_ip" field.
func ClientIPNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldClientIP)))
	})
}

// ClientIPEqualFold applies the EqualFold predicate on the "client_ip" field.
func ClientIPEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldClientIP), v))
	})
}

// ClientIPContainsFold applies the ContainsFold predicate on the "client_ip" field.
func ClientIPContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldClientIP), v))
	})
}

// CostTimeEQ applies the EQ predicate on the "cost_time" field.
func CostTimeEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCostTime), v))
	})
}

// CostTimeNEQ applies the NEQ predicate on the "cost_time" field.
func CostTimeNEQ(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCostTime), v))
	})
}

// CostTimeIn applies the In predicate on the "cost_time" field.
func CostTimeIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCostTime), v...))
	})
}

// CostTimeNotIn applies the NotIn predicate on the "cost_time" field.
func CostTimeNotIn(vs ...string) predicate.Audit {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Audit(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCostTime), v...))
	})
}

// CostTimeGT applies the GT predicate on the "cost_time" field.
func CostTimeGT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCostTime), v))
	})
}

// CostTimeGTE applies the GTE predicate on the "cost_time" field.
func CostTimeGTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCostTime), v))
	})
}

// CostTimeLT applies the LT predicate on the "cost_time" field.
func CostTimeLT(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCostTime), v))
	})
}

// CostTimeLTE applies the LTE predicate on the "cost_time" field.
func CostTimeLTE(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCostTime), v))
	})
}

// CostTimeContains applies the Contains predicate on the "cost_time" field.
func CostTimeContains(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCostTime), v))
	})
}

// CostTimeHasPrefix applies the HasPrefix predicate on the "cost_time" field.
func CostTimeHasPrefix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCostTime), v))
	})
}

// CostTimeHasSuffix applies the HasSuffix predicate on the "cost_time" field.
func CostTimeHasSuffix(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCostTime), v))
	})
}

// CostTimeIsNil applies the IsNil predicate on the "cost_time" field.
func CostTimeIsNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCostTime)))
	})
}

// CostTimeNotNil applies the NotNil predicate on the "cost_time" field.
func CostTimeNotNil() predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCostTime)))
	})
}

// CostTimeEqualFold applies the EqualFold predicate on the "cost_time" field.
func CostTimeEqualFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCostTime), v))
	})
}

// CostTimeContainsFold applies the ContainsFold predicate on the "cost_time" field.
func CostTimeContainsFold(v string) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCostTime), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Audit) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Audit) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Audit) predicate.Audit {
	return predicate.Audit(func(s *sql.Selector) {
		p(s.Not())
	})
}
