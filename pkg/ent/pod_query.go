// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"hello/pkg/ent/pod"
	"hello/pkg/ent/predicate"
	"hello/pkg/ent/spiderdevtblservicetree"
	"math"
	"reflect"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// PodQuery is the builder for querying Pod entities.
type PodQuery struct {
	config
	limit      *int
	offset     *int
	unique     *bool
	order      []OrderFunc
	fields     []string
	predicates []predicate.Pod
	// eager-loading edges.
	withServicetree *SpiderDevTblServicetreeQuery
	withFKs         bool
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the PodQuery builder.
func (pq *PodQuery) Where(ps ...predicate.Pod) *PodQuery {
	pq.predicates = append(pq.predicates, ps...)
	return pq
}

// Limit adds a limit step to the query.
func (pq *PodQuery) Limit(limit int) *PodQuery {
	pq.limit = &limit
	return pq
}

// Offset adds an offset step to the query.
func (pq *PodQuery) Offset(offset int) *PodQuery {
	pq.offset = &offset
	return pq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (pq *PodQuery) Unique(unique bool) *PodQuery {
	pq.unique = &unique
	return pq
}

// Order adds an order step to the query.
func (pq *PodQuery) Order(o ...OrderFunc) *PodQuery {
	pq.order = append(pq.order, o...)
	return pq
}

// QueryServicetree chains the current query on the "servicetree" edge.
func (pq *PodQuery) QueryServicetree() *SpiderDevTblServicetreeQuery {
	query := &SpiderDevTblServicetreeQuery{config: pq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := pq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := pq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(pod.Table, pod.FieldID, selector),
			sqlgraph.To(spiderdevtblservicetree.Table, spiderdevtblservicetree.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pod.ServicetreeTable, pod.ServicetreeColumn),
		)
		fromU = sqlgraph.SetNeighbors(pq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first Pod entity from the query.
// Returns a *NotFoundError when no Pod was found.
func (pq *PodQuery) First(ctx context.Context) (*Pod, error) {
	nodes, err := pq.Limit(1).All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{pod.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (pq *PodQuery) FirstX(ctx context.Context) *Pod {
	node, err := pq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first Pod ID from the query.
// Returns a *NotFoundError when no Pod ID was found.
func (pq *PodQuery) FirstID(ctx context.Context) (id int64, err error) {
	var ids []int64
	if ids, err = pq.Limit(1).IDs(ctx); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{pod.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (pq *PodQuery) FirstIDX(ctx context.Context) int64 {
	id, err := pq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single Pod entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Pod entity is found.
// Returns a *NotFoundError when no Pod entities are found.
func (pq *PodQuery) Only(ctx context.Context) (*Pod, error) {
	nodes, err := pq.Limit(2).All(ctx)
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{pod.Label}
	default:
		return nil, &NotSingularError{pod.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (pq *PodQuery) OnlyX(ctx context.Context) *Pod {
	node, err := pq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only Pod ID in the query.
// Returns a *NotSingularError when more than one Pod ID is found.
// Returns a *NotFoundError when no entities are found.
func (pq *PodQuery) OnlyID(ctx context.Context) (id int64, err error) {
	var ids []int64
	if ids, err = pq.Limit(2).IDs(ctx); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = &NotSingularError{pod.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (pq *PodQuery) OnlyIDX(ctx context.Context) int64 {
	id, err := pq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Pods.
func (pq *PodQuery) All(ctx context.Context) ([]*Pod, error) {
	if err := pq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	return pq.sqlAll(ctx)
}

// AllX is like All, but panics if an error occurs.
func (pq *PodQuery) AllX(ctx context.Context) []*Pod {
	nodes, err := pq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of Pod IDs.
func (pq *PodQuery) IDs(ctx context.Context) ([]int64, error) {
	var ids []int64
	if err := pq.Select(pod.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (pq *PodQuery) IDsX(ctx context.Context) []int64 {
	ids, err := pq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (pq *PodQuery) Count(ctx context.Context) (int, error) {
	if err := pq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return pq.sqlCount(ctx)
}

// CountX is like Count, but panics if an error occurs.
func (pq *PodQuery) CountX(ctx context.Context) int {
	count, err := pq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (pq *PodQuery) Exist(ctx context.Context) (bool, error) {
	if err := pq.prepareQuery(ctx); err != nil {
		return false, err
	}
	return pq.sqlExist(ctx)
}

// ExistX is like Exist, but panics if an error occurs.
func (pq *PodQuery) ExistX(ctx context.Context) bool {
	exist, err := pq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the PodQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (pq *PodQuery) Clone() *PodQuery {
	if pq == nil {
		return nil
	}
	return &PodQuery{
		config:          pq.config,
		limit:           pq.limit,
		offset:          pq.offset,
		order:           append([]OrderFunc{}, pq.order...),
		predicates:      append([]predicate.Pod{}, pq.predicates...),
		withServicetree: pq.withServicetree.Clone(),
		// clone intermediate query.
		sql:    pq.sql.Clone(),
		path:   pq.path,
		unique: pq.unique,
	}
}

// WithServicetree tells the query-builder to eager-load the nodes that are connected to
// the "servicetree" edge. The optional arguments are used to configure the query builder of the edge.
func (pq *PodQuery) WithServicetree(opts ...func(*SpiderDevTblServicetreeQuery)) *PodQuery {
	query := &SpiderDevTblServicetreeQuery{config: pq.config}
	for _, opt := range opts {
		opt(query)
	}
	pq.withServicetree = query
	return pq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		ClusterName string `json:"cluster_name,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.Pod.Query().
//		GroupBy(pod.FieldClusterName).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
//
func (pq *PodQuery) GroupBy(field string, fields ...string) *PodGroupBy {
	group := &PodGroupBy{config: pq.config}
	group.fields = append([]string{field}, fields...)
	group.path = func(ctx context.Context) (prev *sql.Selector, err error) {
		if err := pq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		return pq.sqlQuery(ctx), nil
	}
	return group
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		ClusterName string `json:"cluster_name,omitempty"`
//	}
//
//	client.Pod.Query().
//		Select(pod.FieldClusterName).
//		Scan(ctx, &v)
//
func (pq *PodQuery) Select(fields ...string) *PodSelect {
	pq.fields = append(pq.fields, fields...)
	return &PodSelect{PodQuery: pq}
}

func (pq *PodQuery) prepareQuery(ctx context.Context) error {
	for _, f := range pq.fields {
		if !pod.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if pq.path != nil {
		prev, err := pq.path(ctx)
		if err != nil {
			return err
		}
		pq.sql = prev
	}
	return nil
}

func (pq *PodQuery) sqlAll(ctx context.Context) ([]*Pod, error) {
	var (
		nodes       = []*Pod{}
		withFKs     = pq.withFKs
		_spec       = pq.querySpec()
		loadedTypes = [1]bool{
			pq.withServicetree != nil,
		}
	)
	if pq.withServicetree != nil {
		withFKs = true
	}
	if withFKs {
		_spec.Node.Columns = append(_spec.Node.Columns, pod.ForeignKeys...)
	}
	_spec.ScanValues = func(columns []string) ([]interface{}, error) {
		node := &Pod{config: pq.config}
		nodes = append(nodes, node)
		return node.scanValues(columns)
	}
	_spec.Assign = func(columns []string, values []interface{}) error {
		if len(nodes) == 0 {
			return fmt.Errorf("ent: Assign called without calling ScanValues")
		}
		node := nodes[len(nodes)-1]
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	if err := sqlgraph.QueryNodes(ctx, pq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}

	if query := pq.withServicetree; query != nil {
		ids := make([]int32, 0, len(nodes))
		nodeids := make(map[int32][]*Pod)
		for i := range nodes {
			if nodes[i].aname == nil {
				continue
			}
			fk := *nodes[i].aname
			if _, ok := nodeids[fk]; !ok {
				ids = append(ids, fk)
			}
			nodeids[fk] = append(nodeids[fk], nodes[i])
		}
		query.Where(spiderdevtblservicetree.IDIn(ids...))
		neighbors, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, n := range neighbors {
			nodes, ok := nodeids[n.ID]
			if !ok {
				return nil, fmt.Errorf(`unexpected foreign-key "aname" returned %v`, n.ID)
			}
			for i := range nodes {
				nodes[i].Edges.Servicetree = n
			}
		}
	}

	return nodes, nil
}

func (pq *PodQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := pq.querySpec()
	_spec.Node.Columns = pq.fields
	if len(pq.fields) > 0 {
		_spec.Unique = pq.unique != nil && *pq.unique
	}
	return sqlgraph.CountNodes(ctx, pq.driver, _spec)
}

func (pq *PodQuery) sqlExist(ctx context.Context) (bool, error) {
	n, err := pq.sqlCount(ctx)
	if err != nil {
		return false, fmt.Errorf("ent: check existence: %w", err)
	}
	return n > 0, nil
}

func (pq *PodQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := &sqlgraph.QuerySpec{
		Node: &sqlgraph.NodeSpec{
			Table:   pod.Table,
			Columns: pod.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt64,
				Column: pod.FieldID,
			},
		},
		From:   pq.sql,
		Unique: true,
	}
	if unique := pq.unique; unique != nil {
		_spec.Unique = *unique
	}
	if fields := pq.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, pod.FieldID)
		for i := range fields {
			if fields[i] != pod.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := pq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := pq.limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := pq.offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := pq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (pq *PodQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(pq.driver.Dialect())
	t1 := builder.Table(pod.Table)
	columns := pq.fields
	if len(columns) == 0 {
		columns = pod.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if pq.sql != nil {
		selector = pq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if pq.unique != nil && *pq.unique {
		selector.Distinct()
	}
	for _, p := range pq.predicates {
		p(selector)
	}
	for _, p := range pq.order {
		p(selector)
	}
	if offset := pq.offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := pq.limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

func (pq *PodQuery) ByQueries(ctx context.Context, i interface{}) (res Pods, count int, err error) {
	SetPodFormQueries(i, pq)
	count, err = pq.Count(ctx)
	if err != nil {
		return
	}
	res, err = pq.All(ctx)
	return
}

type PodTableFormer interface {
	Query(q *PodQuery)
}

type PodTablePagingForm struct {
	Limit *int `json:"_limit" form:"_limit"`
	Page  *int `json:"_page" form:"_page"`
}

func (f PodTablePagingForm) Query(q *PodQuery) {
	if f.Limit != nil && f.Page != nil {
		q.Limit(*f.Limit).Offset((*f.Page - 1) * *f.Limit)
	}
}

type PodTableOrderForm struct {
	Order  *string `json:"order" form:"_order" binding:"omitempty,oneof=acs desc"`
	SortBy *string `json:"sortBy" form:"_sortBy"`
}

func (f PodTableOrderForm) Query(q *PodQuery) {
	if f.Order != nil && f.SortBy != nil {
		if *f.Order == "acs" {
			q.Order(Asc(*f.SortBy))
		}

		if *f.Order == "desc" {
			q.Order(Desc(*f.SortBy))
		}
	}
}

func SetPodFormQueries(o interface{}, q *PodQuery) []PodTableFormer {
	l := make([]PodTableFormer, 0)
	v := reflect.ValueOf(o)
	former := reflect.TypeOf((*PodTableFormer)(nil)).Elem()
	PodFormDepValue(v, former, &l)
	for _, e := range l {
		e.Query(q)
	}
	return l
}

func PodFormDepValue(v reflect.Value, former reflect.Type, l *[]PodTableFormer) {
	for i := 0; i < v.NumField(); i++ {
		f := v.Field(i)
		if f.IsZero() {
			continue
		}
		if f.Type().Implements(former) {
			*l = append(*l, f.Interface().(PodTableFormer))
			continue
		}
		if f.Type().Kind() == reflect.Struct {
			PodFormDepValue(f, former, l)
		}
	}
}

type PodTableClusterNameEQForm struct {
	ClusterNameEQ *string `form:"ClusterNameEQ" json:"ClusterNameEQ"`
}

func (f PodTableClusterNameEQForm) Query(q *PodQuery) {
	if f.ClusterNameEQ != nil {
		q.Where(pod.ClusterNameEQ(*f.ClusterNameEQ))
	}
}

type PodTableClusterNameNEQForm struct {
	ClusterNameNEQ *string `form:"ClusterNameNEQ" json:"ClusterNameNEQ"`
}

func (f PodTableClusterNameNEQForm) Query(q *PodQuery) {
	if f.ClusterNameNEQ != nil {
		q.Where(pod.ClusterNameNEQ(*f.ClusterNameNEQ))
	}
}

type PodTableClusterNameInForm struct {
	ClusterNameIn *[]string `form:"ClusterNameIn" json:"ClusterNameIn"`
}

func (f PodTableClusterNameInForm) Query(q *PodQuery) {
	if f.ClusterNameIn != nil {
		q.Where(pod.ClusterNameIn(*f.ClusterNameIn...))
	}
}

type PodTableClusterNameNotInForm struct {
	ClusterNameNotIn *[]string `form:"ClusterNameNotIn" json:"ClusterNameNotIn"`
}

func (f PodTableClusterNameNotInForm) Query(q *PodQuery) {
	if f.ClusterNameNotIn != nil {
		q.Where(pod.ClusterNameNotIn(*f.ClusterNameNotIn...))
	}
}

type PodTableClusterNameGTForm struct {
	ClusterNameGT *string `form:"ClusterNameGT" json:"ClusterNameGT"`
}

func (f PodTableClusterNameGTForm) Query(q *PodQuery) {
	if f.ClusterNameGT != nil {
		q.Where(pod.ClusterNameGT(*f.ClusterNameGT))
	}
}

type PodTableClusterNameGTEForm struct {
	ClusterNameGTE *string `form:"ClusterNameGTE" json:"ClusterNameGTE"`
}

func (f PodTableClusterNameGTEForm) Query(q *PodQuery) {
	if f.ClusterNameGTE != nil {
		q.Where(pod.ClusterNameGTE(*f.ClusterNameGTE))
	}
}

type PodTableClusterNameLTForm struct {
	ClusterNameLT *string `form:"ClusterNameLT" json:"ClusterNameLT"`
}

func (f PodTableClusterNameLTForm) Query(q *PodQuery) {
	if f.ClusterNameLT != nil {
		q.Where(pod.ClusterNameLT(*f.ClusterNameLT))
	}
}

type PodTableClusterNameLTEForm struct {
	ClusterNameLTE *string `form:"ClusterNameLTE" json:"ClusterNameLTE"`
}

func (f PodTableClusterNameLTEForm) Query(q *PodQuery) {
	if f.ClusterNameLTE != nil {
		q.Where(pod.ClusterNameLTE(*f.ClusterNameLTE))
	}
}

type PodTableClusterNameContainsForm struct {
	ClusterNameContains *string `form:"ClusterNameContains" json:"ClusterNameContains"`
}

func (f PodTableClusterNameContainsForm) Query(q *PodQuery) {
	if f.ClusterNameContains != nil {
		q.Where(pod.ClusterNameContains(*f.ClusterNameContains))
	}
}

type PodTableClusterNameHasPrefixForm struct {
	ClusterNameHasPrefix *string `form:"ClusterNameHasPrefix" json:"ClusterNameHasPrefix"`
}

func (f PodTableClusterNameHasPrefixForm) Query(q *PodQuery) {
	if f.ClusterNameHasPrefix != nil {
		q.Where(pod.ClusterNameHasPrefix(*f.ClusterNameHasPrefix))
	}
}

type PodTableClusterNameHasSuffixForm struct {
	ClusterNameHasSuffix *string `form:"ClusterNameHasSuffix" json:"ClusterNameHasSuffix"`
}

func (f PodTableClusterNameHasSuffixForm) Query(q *PodQuery) {
	if f.ClusterNameHasSuffix != nil {
		q.Where(pod.ClusterNameHasSuffix(*f.ClusterNameHasSuffix))
	}
}

type PodTableClusterNameEqualFoldForm struct {
	ClusterNameEqualFold *string `form:"ClusterNameEqualFold" json:"ClusterNameEqualFold"`
}

func (f PodTableClusterNameEqualFoldForm) Query(q *PodQuery) {
	if f.ClusterNameEqualFold != nil {
		q.Where(pod.ClusterNameEqualFold(*f.ClusterNameEqualFold))
	}
}

type PodTableClusterNameContainsFoldForm struct {
	ClusterNameContainsFold *string `form:"ClusterNameContainsFold" json:"ClusterNameContainsFold"`
}

func (f PodTableClusterNameContainsFoldForm) Query(q *PodQuery) {
	if f.ClusterNameContainsFold != nil {
		q.Where(pod.ClusterNameContainsFold(*f.ClusterNameContainsFold))
	}
}

type PodTableNamespaceEQForm struct {
	NamespaceEQ *string `form:"NamespaceEQ" json:"NamespaceEQ"`
}

func (f PodTableNamespaceEQForm) Query(q *PodQuery) {
	if f.NamespaceEQ != nil {
		q.Where(pod.NamespaceEQ(*f.NamespaceEQ))
	}
}

type PodTableNamespaceNEQForm struct {
	NamespaceNEQ *string `form:"NamespaceNEQ" json:"NamespaceNEQ"`
}

func (f PodTableNamespaceNEQForm) Query(q *PodQuery) {
	if f.NamespaceNEQ != nil {
		q.Where(pod.NamespaceNEQ(*f.NamespaceNEQ))
	}
}

type PodTableNamespaceInForm struct {
	NamespaceIn *[]string `form:"NamespaceIn" json:"NamespaceIn"`
}

func (f PodTableNamespaceInForm) Query(q *PodQuery) {
	if f.NamespaceIn != nil {
		q.Where(pod.NamespaceIn(*f.NamespaceIn...))
	}
}

type PodTableNamespaceNotInForm struct {
	NamespaceNotIn *[]string `form:"NamespaceNotIn" json:"NamespaceNotIn"`
}

func (f PodTableNamespaceNotInForm) Query(q *PodQuery) {
	if f.NamespaceNotIn != nil {
		q.Where(pod.NamespaceNotIn(*f.NamespaceNotIn...))
	}
}

type PodTableNamespaceGTForm struct {
	NamespaceGT *string `form:"NamespaceGT" json:"NamespaceGT"`
}

func (f PodTableNamespaceGTForm) Query(q *PodQuery) {
	if f.NamespaceGT != nil {
		q.Where(pod.NamespaceGT(*f.NamespaceGT))
	}
}

type PodTableNamespaceGTEForm struct {
	NamespaceGTE *string `form:"NamespaceGTE" json:"NamespaceGTE"`
}

func (f PodTableNamespaceGTEForm) Query(q *PodQuery) {
	if f.NamespaceGTE != nil {
		q.Where(pod.NamespaceGTE(*f.NamespaceGTE))
	}
}

type PodTableNamespaceLTForm struct {
	NamespaceLT *string `form:"NamespaceLT" json:"NamespaceLT"`
}

func (f PodTableNamespaceLTForm) Query(q *PodQuery) {
	if f.NamespaceLT != nil {
		q.Where(pod.NamespaceLT(*f.NamespaceLT))
	}
}

type PodTableNamespaceLTEForm struct {
	NamespaceLTE *string `form:"NamespaceLTE" json:"NamespaceLTE"`
}

func (f PodTableNamespaceLTEForm) Query(q *PodQuery) {
	if f.NamespaceLTE != nil {
		q.Where(pod.NamespaceLTE(*f.NamespaceLTE))
	}
}

type PodTableNamespaceContainsForm struct {
	NamespaceContains *string `form:"NamespaceContains" json:"NamespaceContains"`
}

func (f PodTableNamespaceContainsForm) Query(q *PodQuery) {
	if f.NamespaceContains != nil {
		q.Where(pod.NamespaceContains(*f.NamespaceContains))
	}
}

type PodTableNamespaceHasPrefixForm struct {
	NamespaceHasPrefix *string `form:"NamespaceHasPrefix" json:"NamespaceHasPrefix"`
}

func (f PodTableNamespaceHasPrefixForm) Query(q *PodQuery) {
	if f.NamespaceHasPrefix != nil {
		q.Where(pod.NamespaceHasPrefix(*f.NamespaceHasPrefix))
	}
}

type PodTableNamespaceHasSuffixForm struct {
	NamespaceHasSuffix *string `form:"NamespaceHasSuffix" json:"NamespaceHasSuffix"`
}

func (f PodTableNamespaceHasSuffixForm) Query(q *PodQuery) {
	if f.NamespaceHasSuffix != nil {
		q.Where(pod.NamespaceHasSuffix(*f.NamespaceHasSuffix))
	}
}

type PodTableNamespaceEqualFoldForm struct {
	NamespaceEqualFold *string `form:"NamespaceEqualFold" json:"NamespaceEqualFold"`
}

func (f PodTableNamespaceEqualFoldForm) Query(q *PodQuery) {
	if f.NamespaceEqualFold != nil {
		q.Where(pod.NamespaceEqualFold(*f.NamespaceEqualFold))
	}
}

type PodTableNamespaceContainsFoldForm struct {
	NamespaceContainsFold *string `form:"NamespaceContainsFold" json:"NamespaceContainsFold"`
}

func (f PodTableNamespaceContainsFoldForm) Query(q *PodQuery) {
	if f.NamespaceContainsFold != nil {
		q.Where(pod.NamespaceContainsFold(*f.NamespaceContainsFold))
	}
}

type PodTableServiceNameEQForm struct {
	ServiceNameEQ *string `form:"ServiceNameEQ" json:"ServiceNameEQ"`
}

func (f PodTableServiceNameEQForm) Query(q *PodQuery) {
	if f.ServiceNameEQ != nil {
		q.Where(pod.ServiceNameEQ(*f.ServiceNameEQ))
	}
}

type PodTableServiceNameNEQForm struct {
	ServiceNameNEQ *string `form:"ServiceNameNEQ" json:"ServiceNameNEQ"`
}

func (f PodTableServiceNameNEQForm) Query(q *PodQuery) {
	if f.ServiceNameNEQ != nil {
		q.Where(pod.ServiceNameNEQ(*f.ServiceNameNEQ))
	}
}

type PodTableServiceNameInForm struct {
	ServiceNameIn *[]string `form:"ServiceNameIn" json:"ServiceNameIn"`
}

func (f PodTableServiceNameInForm) Query(q *PodQuery) {
	if f.ServiceNameIn != nil {
		q.Where(pod.ServiceNameIn(*f.ServiceNameIn...))
	}
}

type PodTableServiceNameNotInForm struct {
	ServiceNameNotIn *[]string `form:"ServiceNameNotIn" json:"ServiceNameNotIn"`
}

func (f PodTableServiceNameNotInForm) Query(q *PodQuery) {
	if f.ServiceNameNotIn != nil {
		q.Where(pod.ServiceNameNotIn(*f.ServiceNameNotIn...))
	}
}

type PodTableServiceNameGTForm struct {
	ServiceNameGT *string `form:"ServiceNameGT" json:"ServiceNameGT"`
}

func (f PodTableServiceNameGTForm) Query(q *PodQuery) {
	if f.ServiceNameGT != nil {
		q.Where(pod.ServiceNameGT(*f.ServiceNameGT))
	}
}

type PodTableServiceNameGTEForm struct {
	ServiceNameGTE *string `form:"ServiceNameGTE" json:"ServiceNameGTE"`
}

func (f PodTableServiceNameGTEForm) Query(q *PodQuery) {
	if f.ServiceNameGTE != nil {
		q.Where(pod.ServiceNameGTE(*f.ServiceNameGTE))
	}
}

type PodTableServiceNameLTForm struct {
	ServiceNameLT *string `form:"ServiceNameLT" json:"ServiceNameLT"`
}

func (f PodTableServiceNameLTForm) Query(q *PodQuery) {
	if f.ServiceNameLT != nil {
		q.Where(pod.ServiceNameLT(*f.ServiceNameLT))
	}
}

type PodTableServiceNameLTEForm struct {
	ServiceNameLTE *string `form:"ServiceNameLTE" json:"ServiceNameLTE"`
}

func (f PodTableServiceNameLTEForm) Query(q *PodQuery) {
	if f.ServiceNameLTE != nil {
		q.Where(pod.ServiceNameLTE(*f.ServiceNameLTE))
	}
}

type PodTableServiceNameContainsForm struct {
	ServiceNameContains *string `form:"ServiceNameContains" json:"ServiceNameContains"`
}

func (f PodTableServiceNameContainsForm) Query(q *PodQuery) {
	if f.ServiceNameContains != nil {
		q.Where(pod.ServiceNameContains(*f.ServiceNameContains))
	}
}

type PodTableServiceNameHasPrefixForm struct {
	ServiceNameHasPrefix *string `form:"ServiceNameHasPrefix" json:"ServiceNameHasPrefix"`
}

func (f PodTableServiceNameHasPrefixForm) Query(q *PodQuery) {
	if f.ServiceNameHasPrefix != nil {
		q.Where(pod.ServiceNameHasPrefix(*f.ServiceNameHasPrefix))
	}
}

type PodTableServiceNameHasSuffixForm struct {
	ServiceNameHasSuffix *string `form:"ServiceNameHasSuffix" json:"ServiceNameHasSuffix"`
}

func (f PodTableServiceNameHasSuffixForm) Query(q *PodQuery) {
	if f.ServiceNameHasSuffix != nil {
		q.Where(pod.ServiceNameHasSuffix(*f.ServiceNameHasSuffix))
	}
}

type PodTableServiceNameEqualFoldForm struct {
	ServiceNameEqualFold *string `form:"ServiceNameEqualFold" json:"ServiceNameEqualFold"`
}

func (f PodTableServiceNameEqualFoldForm) Query(q *PodQuery) {
	if f.ServiceNameEqualFold != nil {
		q.Where(pod.ServiceNameEqualFold(*f.ServiceNameEqualFold))
	}
}

type PodTableServiceNameContainsFoldForm struct {
	ServiceNameContainsFold *string `form:"ServiceNameContainsFold" json:"ServiceNameContainsFold"`
}

func (f PodTableServiceNameContainsFoldForm) Query(q *PodQuery) {
	if f.ServiceNameContainsFold != nil {
		q.Where(pod.ServiceNameContainsFold(*f.ServiceNameContainsFold))
	}
}

type PodTablePodNameEQForm struct {
	PodNameEQ *string `form:"PodNameEQ" json:"PodNameEQ"`
}

func (f PodTablePodNameEQForm) Query(q *PodQuery) {
	if f.PodNameEQ != nil {
		q.Where(pod.PodNameEQ(*f.PodNameEQ))
	}
}

type PodTablePodNameNEQForm struct {
	PodNameNEQ *string `form:"PodNameNEQ" json:"PodNameNEQ"`
}

func (f PodTablePodNameNEQForm) Query(q *PodQuery) {
	if f.PodNameNEQ != nil {
		q.Where(pod.PodNameNEQ(*f.PodNameNEQ))
	}
}

type PodTablePodNameInForm struct {
	PodNameIn *[]string `form:"PodNameIn" json:"PodNameIn"`
}

func (f PodTablePodNameInForm) Query(q *PodQuery) {
	if f.PodNameIn != nil {
		q.Where(pod.PodNameIn(*f.PodNameIn...))
	}
}

type PodTablePodNameNotInForm struct {
	PodNameNotIn *[]string `form:"PodNameNotIn" json:"PodNameNotIn"`
}

func (f PodTablePodNameNotInForm) Query(q *PodQuery) {
	if f.PodNameNotIn != nil {
		q.Where(pod.PodNameNotIn(*f.PodNameNotIn...))
	}
}

type PodTablePodNameGTForm struct {
	PodNameGT *string `form:"PodNameGT" json:"PodNameGT"`
}

func (f PodTablePodNameGTForm) Query(q *PodQuery) {
	if f.PodNameGT != nil {
		q.Where(pod.PodNameGT(*f.PodNameGT))
	}
}

type PodTablePodNameGTEForm struct {
	PodNameGTE *string `form:"PodNameGTE" json:"PodNameGTE"`
}

func (f PodTablePodNameGTEForm) Query(q *PodQuery) {
	if f.PodNameGTE != nil {
		q.Where(pod.PodNameGTE(*f.PodNameGTE))
	}
}

type PodTablePodNameLTForm struct {
	PodNameLT *string `form:"PodNameLT" json:"PodNameLT"`
}

func (f PodTablePodNameLTForm) Query(q *PodQuery) {
	if f.PodNameLT != nil {
		q.Where(pod.PodNameLT(*f.PodNameLT))
	}
}

type PodTablePodNameLTEForm struct {
	PodNameLTE *string `form:"PodNameLTE" json:"PodNameLTE"`
}

func (f PodTablePodNameLTEForm) Query(q *PodQuery) {
	if f.PodNameLTE != nil {
		q.Where(pod.PodNameLTE(*f.PodNameLTE))
	}
}

type PodTablePodNameContainsForm struct {
	PodNameContains *string `form:"PodNameContains" json:"PodNameContains"`
}

func (f PodTablePodNameContainsForm) Query(q *PodQuery) {
	if f.PodNameContains != nil {
		q.Where(pod.PodNameContains(*f.PodNameContains))
	}
}

type PodTablePodNameHasPrefixForm struct {
	PodNameHasPrefix *string `form:"PodNameHasPrefix" json:"PodNameHasPrefix"`
}

func (f PodTablePodNameHasPrefixForm) Query(q *PodQuery) {
	if f.PodNameHasPrefix != nil {
		q.Where(pod.PodNameHasPrefix(*f.PodNameHasPrefix))
	}
}

type PodTablePodNameHasSuffixForm struct {
	PodNameHasSuffix *string `form:"PodNameHasSuffix" json:"PodNameHasSuffix"`
}

func (f PodTablePodNameHasSuffixForm) Query(q *PodQuery) {
	if f.PodNameHasSuffix != nil {
		q.Where(pod.PodNameHasSuffix(*f.PodNameHasSuffix))
	}
}

type PodTablePodNameEqualFoldForm struct {
	PodNameEqualFold *string `form:"PodNameEqualFold" json:"PodNameEqualFold"`
}

func (f PodTablePodNameEqualFoldForm) Query(q *PodQuery) {
	if f.PodNameEqualFold != nil {
		q.Where(pod.PodNameEqualFold(*f.PodNameEqualFold))
	}
}

type PodTablePodNameContainsFoldForm struct {
	PodNameContainsFold *string `form:"PodNameContainsFold" json:"PodNameContainsFold"`
}

func (f PodTablePodNameContainsFoldForm) Query(q *PodQuery) {
	if f.PodNameContainsFold != nil {
		q.Where(pod.PodNameContainsFold(*f.PodNameContainsFold))
	}
}

type PodTableResourceVersionEQForm struct {
	ResourceVersionEQ *string `form:"ResourceVersionEQ" json:"ResourceVersionEQ"`
}

func (f PodTableResourceVersionEQForm) Query(q *PodQuery) {
	if f.ResourceVersionEQ != nil {
		q.Where(pod.ResourceVersionEQ(*f.ResourceVersionEQ))
	}
}

type PodTableResourceVersionNEQForm struct {
	ResourceVersionNEQ *string `form:"ResourceVersionNEQ" json:"ResourceVersionNEQ"`
}

func (f PodTableResourceVersionNEQForm) Query(q *PodQuery) {
	if f.ResourceVersionNEQ != nil {
		q.Where(pod.ResourceVersionNEQ(*f.ResourceVersionNEQ))
	}
}

type PodTableResourceVersionInForm struct {
	ResourceVersionIn *[]string `form:"ResourceVersionIn" json:"ResourceVersionIn"`
}

func (f PodTableResourceVersionInForm) Query(q *PodQuery) {
	if f.ResourceVersionIn != nil {
		q.Where(pod.ResourceVersionIn(*f.ResourceVersionIn...))
	}
}

type PodTableResourceVersionNotInForm struct {
	ResourceVersionNotIn *[]string `form:"ResourceVersionNotIn" json:"ResourceVersionNotIn"`
}

func (f PodTableResourceVersionNotInForm) Query(q *PodQuery) {
	if f.ResourceVersionNotIn != nil {
		q.Where(pod.ResourceVersionNotIn(*f.ResourceVersionNotIn...))
	}
}

type PodTableResourceVersionGTForm struct {
	ResourceVersionGT *string `form:"ResourceVersionGT" json:"ResourceVersionGT"`
}

func (f PodTableResourceVersionGTForm) Query(q *PodQuery) {
	if f.ResourceVersionGT != nil {
		q.Where(pod.ResourceVersionGT(*f.ResourceVersionGT))
	}
}

type PodTableResourceVersionGTEForm struct {
	ResourceVersionGTE *string `form:"ResourceVersionGTE" json:"ResourceVersionGTE"`
}

func (f PodTableResourceVersionGTEForm) Query(q *PodQuery) {
	if f.ResourceVersionGTE != nil {
		q.Where(pod.ResourceVersionGTE(*f.ResourceVersionGTE))
	}
}

type PodTableResourceVersionLTForm struct {
	ResourceVersionLT *string `form:"ResourceVersionLT" json:"ResourceVersionLT"`
}

func (f PodTableResourceVersionLTForm) Query(q *PodQuery) {
	if f.ResourceVersionLT != nil {
		q.Where(pod.ResourceVersionLT(*f.ResourceVersionLT))
	}
}

type PodTableResourceVersionLTEForm struct {
	ResourceVersionLTE *string `form:"ResourceVersionLTE" json:"ResourceVersionLTE"`
}

func (f PodTableResourceVersionLTEForm) Query(q *PodQuery) {
	if f.ResourceVersionLTE != nil {
		q.Where(pod.ResourceVersionLTE(*f.ResourceVersionLTE))
	}
}

type PodTableResourceVersionContainsForm struct {
	ResourceVersionContains *string `form:"ResourceVersionContains" json:"ResourceVersionContains"`
}

func (f PodTableResourceVersionContainsForm) Query(q *PodQuery) {
	if f.ResourceVersionContains != nil {
		q.Where(pod.ResourceVersionContains(*f.ResourceVersionContains))
	}
}

type PodTableResourceVersionHasPrefixForm struct {
	ResourceVersionHasPrefix *string `form:"ResourceVersionHasPrefix" json:"ResourceVersionHasPrefix"`
}

func (f PodTableResourceVersionHasPrefixForm) Query(q *PodQuery) {
	if f.ResourceVersionHasPrefix != nil {
		q.Where(pod.ResourceVersionHasPrefix(*f.ResourceVersionHasPrefix))
	}
}

type PodTableResourceVersionHasSuffixForm struct {
	ResourceVersionHasSuffix *string `form:"ResourceVersionHasSuffix" json:"ResourceVersionHasSuffix"`
}

func (f PodTableResourceVersionHasSuffixForm) Query(q *PodQuery) {
	if f.ResourceVersionHasSuffix != nil {
		q.Where(pod.ResourceVersionHasSuffix(*f.ResourceVersionHasSuffix))
	}
}

type PodTableResourceVersionEqualFoldForm struct {
	ResourceVersionEqualFold *string `form:"ResourceVersionEqualFold" json:"ResourceVersionEqualFold"`
}

func (f PodTableResourceVersionEqualFoldForm) Query(q *PodQuery) {
	if f.ResourceVersionEqualFold != nil {
		q.Where(pod.ResourceVersionEqualFold(*f.ResourceVersionEqualFold))
	}
}

type PodTableResourceVersionContainsFoldForm struct {
	ResourceVersionContainsFold *string `form:"ResourceVersionContainsFold" json:"ResourceVersionContainsFold"`
}

func (f PodTableResourceVersionContainsFoldForm) Query(q *PodQuery) {
	if f.ResourceVersionContainsFold != nil {
		q.Where(pod.ResourceVersionContainsFold(*f.ResourceVersionContainsFold))
	}
}

type PodTablePodIPEQForm struct {
	PodIPEQ *string `form:"PodIPEQ" json:"PodIPEQ"`
}

func (f PodTablePodIPEQForm) Query(q *PodQuery) {
	if f.PodIPEQ != nil {
		q.Where(pod.PodIPEQ(*f.PodIPEQ))
	}
}

type PodTablePodIPNEQForm struct {
	PodIPNEQ *string `form:"PodIPNEQ" json:"PodIPNEQ"`
}

func (f PodTablePodIPNEQForm) Query(q *PodQuery) {
	if f.PodIPNEQ != nil {
		q.Where(pod.PodIPNEQ(*f.PodIPNEQ))
	}
}

type PodTablePodIPInForm struct {
	PodIPIn *[]string `form:"PodIPIn" json:"PodIPIn"`
}

func (f PodTablePodIPInForm) Query(q *PodQuery) {
	if f.PodIPIn != nil {
		q.Where(pod.PodIPIn(*f.PodIPIn...))
	}
}

type PodTablePodIPNotInForm struct {
	PodIPNotIn *[]string `form:"PodIPNotIn" json:"PodIPNotIn"`
}

func (f PodTablePodIPNotInForm) Query(q *PodQuery) {
	if f.PodIPNotIn != nil {
		q.Where(pod.PodIPNotIn(*f.PodIPNotIn...))
	}
}

type PodTablePodIPGTForm struct {
	PodIPGT *string `form:"PodIPGT" json:"PodIPGT"`
}

func (f PodTablePodIPGTForm) Query(q *PodQuery) {
	if f.PodIPGT != nil {
		q.Where(pod.PodIPGT(*f.PodIPGT))
	}
}

type PodTablePodIPGTEForm struct {
	PodIPGTE *string `form:"PodIPGTE" json:"PodIPGTE"`
}

func (f PodTablePodIPGTEForm) Query(q *PodQuery) {
	if f.PodIPGTE != nil {
		q.Where(pod.PodIPGTE(*f.PodIPGTE))
	}
}

type PodTablePodIPLTForm struct {
	PodIPLT *string `form:"PodIPLT" json:"PodIPLT"`
}

func (f PodTablePodIPLTForm) Query(q *PodQuery) {
	if f.PodIPLT != nil {
		q.Where(pod.PodIPLT(*f.PodIPLT))
	}
}

type PodTablePodIPLTEForm struct {
	PodIPLTE *string `form:"PodIPLTE" json:"PodIPLTE"`
}

func (f PodTablePodIPLTEForm) Query(q *PodQuery) {
	if f.PodIPLTE != nil {
		q.Where(pod.PodIPLTE(*f.PodIPLTE))
	}
}

type PodTablePodIPContainsForm struct {
	PodIPContains *string `form:"PodIPContains" json:"PodIPContains"`
}

func (f PodTablePodIPContainsForm) Query(q *PodQuery) {
	if f.PodIPContains != nil {
		q.Where(pod.PodIPContains(*f.PodIPContains))
	}
}

type PodTablePodIPHasPrefixForm struct {
	PodIPHasPrefix *string `form:"PodIPHasPrefix" json:"PodIPHasPrefix"`
}

func (f PodTablePodIPHasPrefixForm) Query(q *PodQuery) {
	if f.PodIPHasPrefix != nil {
		q.Where(pod.PodIPHasPrefix(*f.PodIPHasPrefix))
	}
}

type PodTablePodIPHasSuffixForm struct {
	PodIPHasSuffix *string `form:"PodIPHasSuffix" json:"PodIPHasSuffix"`
}

func (f PodTablePodIPHasSuffixForm) Query(q *PodQuery) {
	if f.PodIPHasSuffix != nil {
		q.Where(pod.PodIPHasSuffix(*f.PodIPHasSuffix))
	}
}

type PodTablePodIPEqualFoldForm struct {
	PodIPEqualFold *string `form:"PodIPEqualFold" json:"PodIPEqualFold"`
}

func (f PodTablePodIPEqualFoldForm) Query(q *PodQuery) {
	if f.PodIPEqualFold != nil {
		q.Where(pod.PodIPEqualFold(*f.PodIPEqualFold))
	}
}

type PodTablePodIPContainsFoldForm struct {
	PodIPContainsFold *string `form:"PodIPContainsFold" json:"PodIPContainsFold"`
}

func (f PodTablePodIPContainsFoldForm) Query(q *PodQuery) {
	if f.PodIPContainsFold != nil {
		q.Where(pod.PodIPContainsFold(*f.PodIPContainsFold))
	}
}

type PodTableHostIPEQForm struct {
	HostIPEQ *string `form:"HostIPEQ" json:"HostIPEQ"`
}

func (f PodTableHostIPEQForm) Query(q *PodQuery) {
	if f.HostIPEQ != nil {
		q.Where(pod.HostIPEQ(*f.HostIPEQ))
	}
}

type PodTableHostIPNEQForm struct {
	HostIPNEQ *string `form:"HostIPNEQ" json:"HostIPNEQ"`
}

func (f PodTableHostIPNEQForm) Query(q *PodQuery) {
	if f.HostIPNEQ != nil {
		q.Where(pod.HostIPNEQ(*f.HostIPNEQ))
	}
}

type PodTableHostIPInForm struct {
	HostIPIn *[]string `form:"HostIPIn" json:"HostIPIn"`
}

func (f PodTableHostIPInForm) Query(q *PodQuery) {
	if f.HostIPIn != nil {
		q.Where(pod.HostIPIn(*f.HostIPIn...))
	}
}

type PodTableHostIPNotInForm struct {
	HostIPNotIn *[]string `form:"HostIPNotIn" json:"HostIPNotIn"`
}

func (f PodTableHostIPNotInForm) Query(q *PodQuery) {
	if f.HostIPNotIn != nil {
		q.Where(pod.HostIPNotIn(*f.HostIPNotIn...))
	}
}

type PodTableHostIPGTForm struct {
	HostIPGT *string `form:"HostIPGT" json:"HostIPGT"`
}

func (f PodTableHostIPGTForm) Query(q *PodQuery) {
	if f.HostIPGT != nil {
		q.Where(pod.HostIPGT(*f.HostIPGT))
	}
}

type PodTableHostIPGTEForm struct {
	HostIPGTE *string `form:"HostIPGTE" json:"HostIPGTE"`
}

func (f PodTableHostIPGTEForm) Query(q *PodQuery) {
	if f.HostIPGTE != nil {
		q.Where(pod.HostIPGTE(*f.HostIPGTE))
	}
}

type PodTableHostIPLTForm struct {
	HostIPLT *string `form:"HostIPLT" json:"HostIPLT"`
}

func (f PodTableHostIPLTForm) Query(q *PodQuery) {
	if f.HostIPLT != nil {
		q.Where(pod.HostIPLT(*f.HostIPLT))
	}
}

type PodTableHostIPLTEForm struct {
	HostIPLTE *string `form:"HostIPLTE" json:"HostIPLTE"`
}

func (f PodTableHostIPLTEForm) Query(q *PodQuery) {
	if f.HostIPLTE != nil {
		q.Where(pod.HostIPLTE(*f.HostIPLTE))
	}
}

type PodTableHostIPContainsForm struct {
	HostIPContains *string `form:"HostIPContains" json:"HostIPContains"`
}

func (f PodTableHostIPContainsForm) Query(q *PodQuery) {
	if f.HostIPContains != nil {
		q.Where(pod.HostIPContains(*f.HostIPContains))
	}
}

type PodTableHostIPHasPrefixForm struct {
	HostIPHasPrefix *string `form:"HostIPHasPrefix" json:"HostIPHasPrefix"`
}

func (f PodTableHostIPHasPrefixForm) Query(q *PodQuery) {
	if f.HostIPHasPrefix != nil {
		q.Where(pod.HostIPHasPrefix(*f.HostIPHasPrefix))
	}
}

type PodTableHostIPHasSuffixForm struct {
	HostIPHasSuffix *string `form:"HostIPHasSuffix" json:"HostIPHasSuffix"`
}

func (f PodTableHostIPHasSuffixForm) Query(q *PodQuery) {
	if f.HostIPHasSuffix != nil {
		q.Where(pod.HostIPHasSuffix(*f.HostIPHasSuffix))
	}
}

type PodTableHostIPEqualFoldForm struct {
	HostIPEqualFold *string `form:"HostIPEqualFold" json:"HostIPEqualFold"`
}

func (f PodTableHostIPEqualFoldForm) Query(q *PodQuery) {
	if f.HostIPEqualFold != nil {
		q.Where(pod.HostIPEqualFold(*f.HostIPEqualFold))
	}
}

type PodTableHostIPContainsFoldForm struct {
	HostIPContainsFold *string `form:"HostIPContainsFold" json:"HostIPContainsFold"`
}

func (f PodTableHostIPContainsFoldForm) Query(q *PodQuery) {
	if f.HostIPContainsFold != nil {
		q.Where(pod.HostIPContainsFold(*f.HostIPContainsFold))
	}
}

type PodTableStartTimeEQForm struct {
	StartTimeEQ *time.Time `form:"StartTimeEQ" json:"StartTimeEQ"`
}

func (f PodTableStartTimeEQForm) Query(q *PodQuery) {
	if f.StartTimeEQ != nil {
		q.Where(pod.StartTimeEQ(*f.StartTimeEQ))
	}
}

type PodTableStartTimeNEQForm struct {
	StartTimeNEQ *time.Time `form:"StartTimeNEQ" json:"StartTimeNEQ"`
}

func (f PodTableStartTimeNEQForm) Query(q *PodQuery) {
	if f.StartTimeNEQ != nil {
		q.Where(pod.StartTimeNEQ(*f.StartTimeNEQ))
	}
}

type PodTableStartTimeInForm struct {
	StartTimeIn *[]time.Time `form:"StartTimeIn" json:"StartTimeIn"`
}

func (f PodTableStartTimeInForm) Query(q *PodQuery) {
	if f.StartTimeIn != nil {
		q.Where(pod.StartTimeIn(*f.StartTimeIn...))
	}
}

type PodTableStartTimeNotInForm struct {
	StartTimeNotIn *[]time.Time `form:"StartTimeNotIn" json:"StartTimeNotIn"`
}

func (f PodTableStartTimeNotInForm) Query(q *PodQuery) {
	if f.StartTimeNotIn != nil {
		q.Where(pod.StartTimeNotIn(*f.StartTimeNotIn...))
	}
}

type PodTableStartTimeGTForm struct {
	StartTimeGT *time.Time `form:"StartTimeGT" json:"StartTimeGT"`
}

func (f PodTableStartTimeGTForm) Query(q *PodQuery) {
	if f.StartTimeGT != nil {
		q.Where(pod.StartTimeGT(*f.StartTimeGT))
	}
}

type PodTableStartTimeGTEForm struct {
	StartTimeGTE *time.Time `form:"StartTimeGTE" json:"StartTimeGTE"`
}

func (f PodTableStartTimeGTEForm) Query(q *PodQuery) {
	if f.StartTimeGTE != nil {
		q.Where(pod.StartTimeGTE(*f.StartTimeGTE))
	}
}

type PodTableStartTimeLTForm struct {
	StartTimeLT *time.Time `form:"StartTimeLT" json:"StartTimeLT"`
}

func (f PodTableStartTimeLTForm) Query(q *PodQuery) {
	if f.StartTimeLT != nil {
		q.Where(pod.StartTimeLT(*f.StartTimeLT))
	}
}

type PodTableStartTimeLTEForm struct {
	StartTimeLTE *time.Time `form:"StartTimeLTE" json:"StartTimeLTE"`
}

func (f PodTableStartTimeLTEForm) Query(q *PodQuery) {
	if f.StartTimeLTE != nil {
		q.Where(pod.StartTimeLTE(*f.StartTimeLTE))
	}
}

type PodTablePhaseEQForm struct {
	PhaseEQ *string `form:"PhaseEQ" json:"PhaseEQ"`
}

func (f PodTablePhaseEQForm) Query(q *PodQuery) {
	if f.PhaseEQ != nil {
		q.Where(pod.PhaseEQ(*f.PhaseEQ))
	}
}

type PodTablePhaseNEQForm struct {
	PhaseNEQ *string `form:"PhaseNEQ" json:"PhaseNEQ"`
}

func (f PodTablePhaseNEQForm) Query(q *PodQuery) {
	if f.PhaseNEQ != nil {
		q.Where(pod.PhaseNEQ(*f.PhaseNEQ))
	}
}

type PodTablePhaseInForm struct {
	PhaseIn *[]string `form:"PhaseIn" json:"PhaseIn"`
}

func (f PodTablePhaseInForm) Query(q *PodQuery) {
	if f.PhaseIn != nil {
		q.Where(pod.PhaseIn(*f.PhaseIn...))
	}
}

type PodTablePhaseNotInForm struct {
	PhaseNotIn *[]string `form:"PhaseNotIn" json:"PhaseNotIn"`
}

func (f PodTablePhaseNotInForm) Query(q *PodQuery) {
	if f.PhaseNotIn != nil {
		q.Where(pod.PhaseNotIn(*f.PhaseNotIn...))
	}
}

type PodTablePhaseGTForm struct {
	PhaseGT *string `form:"PhaseGT" json:"PhaseGT"`
}

func (f PodTablePhaseGTForm) Query(q *PodQuery) {
	if f.PhaseGT != nil {
		q.Where(pod.PhaseGT(*f.PhaseGT))
	}
}

type PodTablePhaseGTEForm struct {
	PhaseGTE *string `form:"PhaseGTE" json:"PhaseGTE"`
}

func (f PodTablePhaseGTEForm) Query(q *PodQuery) {
	if f.PhaseGTE != nil {
		q.Where(pod.PhaseGTE(*f.PhaseGTE))
	}
}

type PodTablePhaseLTForm struct {
	PhaseLT *string `form:"PhaseLT" json:"PhaseLT"`
}

func (f PodTablePhaseLTForm) Query(q *PodQuery) {
	if f.PhaseLT != nil {
		q.Where(pod.PhaseLT(*f.PhaseLT))
	}
}

type PodTablePhaseLTEForm struct {
	PhaseLTE *string `form:"PhaseLTE" json:"PhaseLTE"`
}

func (f PodTablePhaseLTEForm) Query(q *PodQuery) {
	if f.PhaseLTE != nil {
		q.Where(pod.PhaseLTE(*f.PhaseLTE))
	}
}

type PodTablePhaseContainsForm struct {
	PhaseContains *string `form:"PhaseContains" json:"PhaseContains"`
}

func (f PodTablePhaseContainsForm) Query(q *PodQuery) {
	if f.PhaseContains != nil {
		q.Where(pod.PhaseContains(*f.PhaseContains))
	}
}

type PodTablePhaseHasPrefixForm struct {
	PhaseHasPrefix *string `form:"PhaseHasPrefix" json:"PhaseHasPrefix"`
}

func (f PodTablePhaseHasPrefixForm) Query(q *PodQuery) {
	if f.PhaseHasPrefix != nil {
		q.Where(pod.PhaseHasPrefix(*f.PhaseHasPrefix))
	}
}

type PodTablePhaseHasSuffixForm struct {
	PhaseHasSuffix *string `form:"PhaseHasSuffix" json:"PhaseHasSuffix"`
}

func (f PodTablePhaseHasSuffixForm) Query(q *PodQuery) {
	if f.PhaseHasSuffix != nil {
		q.Where(pod.PhaseHasSuffix(*f.PhaseHasSuffix))
	}
}

type PodTablePhaseEqualFoldForm struct {
	PhaseEqualFold *string `form:"PhaseEqualFold" json:"PhaseEqualFold"`
}

func (f PodTablePhaseEqualFoldForm) Query(q *PodQuery) {
	if f.PhaseEqualFold != nil {
		q.Where(pod.PhaseEqualFold(*f.PhaseEqualFold))
	}
}

type PodTablePhaseContainsFoldForm struct {
	PhaseContainsFold *string `form:"PhaseContainsFold" json:"PhaseContainsFold"`
}

func (f PodTablePhaseContainsFoldForm) Query(q *PodQuery) {
	if f.PhaseContainsFold != nil {
		q.Where(pod.PhaseContainsFold(*f.PhaseContainsFold))
	}
}

type PodTableReasonEQForm struct {
	ReasonEQ *string `form:"ReasonEQ" json:"ReasonEQ"`
}

func (f PodTableReasonEQForm) Query(q *PodQuery) {
	if f.ReasonEQ != nil {
		q.Where(pod.ReasonEQ(*f.ReasonEQ))
	}
}

type PodTableReasonNEQForm struct {
	ReasonNEQ *string `form:"ReasonNEQ" json:"ReasonNEQ"`
}

func (f PodTableReasonNEQForm) Query(q *PodQuery) {
	if f.ReasonNEQ != nil {
		q.Where(pod.ReasonNEQ(*f.ReasonNEQ))
	}
}

type PodTableReasonInForm struct {
	ReasonIn *[]string `form:"ReasonIn" json:"ReasonIn"`
}

func (f PodTableReasonInForm) Query(q *PodQuery) {
	if f.ReasonIn != nil {
		q.Where(pod.ReasonIn(*f.ReasonIn...))
	}
}

type PodTableReasonNotInForm struct {
	ReasonNotIn *[]string `form:"ReasonNotIn" json:"ReasonNotIn"`
}

func (f PodTableReasonNotInForm) Query(q *PodQuery) {
	if f.ReasonNotIn != nil {
		q.Where(pod.ReasonNotIn(*f.ReasonNotIn...))
	}
}

type PodTableReasonGTForm struct {
	ReasonGT *string `form:"ReasonGT" json:"ReasonGT"`
}

func (f PodTableReasonGTForm) Query(q *PodQuery) {
	if f.ReasonGT != nil {
		q.Where(pod.ReasonGT(*f.ReasonGT))
	}
}

type PodTableReasonGTEForm struct {
	ReasonGTE *string `form:"ReasonGTE" json:"ReasonGTE"`
}

func (f PodTableReasonGTEForm) Query(q *PodQuery) {
	if f.ReasonGTE != nil {
		q.Where(pod.ReasonGTE(*f.ReasonGTE))
	}
}

type PodTableReasonLTForm struct {
	ReasonLT *string `form:"ReasonLT" json:"ReasonLT"`
}

func (f PodTableReasonLTForm) Query(q *PodQuery) {
	if f.ReasonLT != nil {
		q.Where(pod.ReasonLT(*f.ReasonLT))
	}
}

type PodTableReasonLTEForm struct {
	ReasonLTE *string `form:"ReasonLTE" json:"ReasonLTE"`
}

func (f PodTableReasonLTEForm) Query(q *PodQuery) {
	if f.ReasonLTE != nil {
		q.Where(pod.ReasonLTE(*f.ReasonLTE))
	}
}

type PodTableReasonContainsForm struct {
	ReasonContains *string `form:"ReasonContains" json:"ReasonContains"`
}

func (f PodTableReasonContainsForm) Query(q *PodQuery) {
	if f.ReasonContains != nil {
		q.Where(pod.ReasonContains(*f.ReasonContains))
	}
}

type PodTableReasonHasPrefixForm struct {
	ReasonHasPrefix *string `form:"ReasonHasPrefix" json:"ReasonHasPrefix"`
}

func (f PodTableReasonHasPrefixForm) Query(q *PodQuery) {
	if f.ReasonHasPrefix != nil {
		q.Where(pod.ReasonHasPrefix(*f.ReasonHasPrefix))
	}
}

type PodTableReasonHasSuffixForm struct {
	ReasonHasSuffix *string `form:"ReasonHasSuffix" json:"ReasonHasSuffix"`
}

func (f PodTableReasonHasSuffixForm) Query(q *PodQuery) {
	if f.ReasonHasSuffix != nil {
		q.Where(pod.ReasonHasSuffix(*f.ReasonHasSuffix))
	}
}

type PodTableReasonEqualFoldForm struct {
	ReasonEqualFold *string `form:"ReasonEqualFold" json:"ReasonEqualFold"`
}

func (f PodTableReasonEqualFoldForm) Query(q *PodQuery) {
	if f.ReasonEqualFold != nil {
		q.Where(pod.ReasonEqualFold(*f.ReasonEqualFold))
	}
}

type PodTableReasonContainsFoldForm struct {
	ReasonContainsFold *string `form:"ReasonContainsFold" json:"ReasonContainsFold"`
}

func (f PodTableReasonContainsFoldForm) Query(q *PodQuery) {
	if f.ReasonContainsFold != nil {
		q.Where(pod.ReasonContainsFold(*f.ReasonContainsFold))
	}
}

type PodTableMessageEQForm struct {
	MessageEQ *string `form:"MessageEQ" json:"MessageEQ"`
}

func (f PodTableMessageEQForm) Query(q *PodQuery) {
	if f.MessageEQ != nil {
		q.Where(pod.MessageEQ(*f.MessageEQ))
	}
}

type PodTableMessageNEQForm struct {
	MessageNEQ *string `form:"MessageNEQ" json:"MessageNEQ"`
}

func (f PodTableMessageNEQForm) Query(q *PodQuery) {
	if f.MessageNEQ != nil {
		q.Where(pod.MessageNEQ(*f.MessageNEQ))
	}
}

type PodTableMessageInForm struct {
	MessageIn *[]string `form:"MessageIn" json:"MessageIn"`
}

func (f PodTableMessageInForm) Query(q *PodQuery) {
	if f.MessageIn != nil {
		q.Where(pod.MessageIn(*f.MessageIn...))
	}
}

type PodTableMessageNotInForm struct {
	MessageNotIn *[]string `form:"MessageNotIn" json:"MessageNotIn"`
}

func (f PodTableMessageNotInForm) Query(q *PodQuery) {
	if f.MessageNotIn != nil {
		q.Where(pod.MessageNotIn(*f.MessageNotIn...))
	}
}

type PodTableMessageGTForm struct {
	MessageGT *string `form:"MessageGT" json:"MessageGT"`
}

func (f PodTableMessageGTForm) Query(q *PodQuery) {
	if f.MessageGT != nil {
		q.Where(pod.MessageGT(*f.MessageGT))
	}
}

type PodTableMessageGTEForm struct {
	MessageGTE *string `form:"MessageGTE" json:"MessageGTE"`
}

func (f PodTableMessageGTEForm) Query(q *PodQuery) {
	if f.MessageGTE != nil {
		q.Where(pod.MessageGTE(*f.MessageGTE))
	}
}

type PodTableMessageLTForm struct {
	MessageLT *string `form:"MessageLT" json:"MessageLT"`
}

func (f PodTableMessageLTForm) Query(q *PodQuery) {
	if f.MessageLT != nil {
		q.Where(pod.MessageLT(*f.MessageLT))
	}
}

type PodTableMessageLTEForm struct {
	MessageLTE *string `form:"MessageLTE" json:"MessageLTE"`
}

func (f PodTableMessageLTEForm) Query(q *PodQuery) {
	if f.MessageLTE != nil {
		q.Where(pod.MessageLTE(*f.MessageLTE))
	}
}

type PodTableMessageContainsForm struct {
	MessageContains *string `form:"MessageContains" json:"MessageContains"`
}

func (f PodTableMessageContainsForm) Query(q *PodQuery) {
	if f.MessageContains != nil {
		q.Where(pod.MessageContains(*f.MessageContains))
	}
}

type PodTableMessageHasPrefixForm struct {
	MessageHasPrefix *string `form:"MessageHasPrefix" json:"MessageHasPrefix"`
}

func (f PodTableMessageHasPrefixForm) Query(q *PodQuery) {
	if f.MessageHasPrefix != nil {
		q.Where(pod.MessageHasPrefix(*f.MessageHasPrefix))
	}
}

type PodTableMessageHasSuffixForm struct {
	MessageHasSuffix *string `form:"MessageHasSuffix" json:"MessageHasSuffix"`
}

func (f PodTableMessageHasSuffixForm) Query(q *PodQuery) {
	if f.MessageHasSuffix != nil {
		q.Where(pod.MessageHasSuffix(*f.MessageHasSuffix))
	}
}

type PodTableMessageEqualFoldForm struct {
	MessageEqualFold *string `form:"MessageEqualFold" json:"MessageEqualFold"`
}

func (f PodTableMessageEqualFoldForm) Query(q *PodQuery) {
	if f.MessageEqualFold != nil {
		q.Where(pod.MessageEqualFold(*f.MessageEqualFold))
	}
}

type PodTableMessageContainsFoldForm struct {
	MessageContainsFold *string `form:"MessageContainsFold" json:"MessageContainsFold"`
}

func (f PodTableMessageContainsFoldForm) Query(q *PodQuery) {
	if f.MessageContainsFold != nil {
		q.Where(pod.MessageContainsFold(*f.MessageContainsFold))
	}
}

type PodTableDetailEQForm struct {
	DetailEQ *string `form:"DetailEQ" json:"DetailEQ"`
}

func (f PodTableDetailEQForm) Query(q *PodQuery) {
	if f.DetailEQ != nil {
		q.Where(pod.DetailEQ(*f.DetailEQ))
	}
}

type PodTableDetailNEQForm struct {
	DetailNEQ *string `form:"DetailNEQ" json:"DetailNEQ"`
}

func (f PodTableDetailNEQForm) Query(q *PodQuery) {
	if f.DetailNEQ != nil {
		q.Where(pod.DetailNEQ(*f.DetailNEQ))
	}
}

type PodTableDetailInForm struct {
	DetailIn *[]string `form:"DetailIn" json:"DetailIn"`
}

func (f PodTableDetailInForm) Query(q *PodQuery) {
	if f.DetailIn != nil {
		q.Where(pod.DetailIn(*f.DetailIn...))
	}
}

type PodTableDetailNotInForm struct {
	DetailNotIn *[]string `form:"DetailNotIn" json:"DetailNotIn"`
}

func (f PodTableDetailNotInForm) Query(q *PodQuery) {
	if f.DetailNotIn != nil {
		q.Where(pod.DetailNotIn(*f.DetailNotIn...))
	}
}

type PodTableDetailGTForm struct {
	DetailGT *string `form:"DetailGT" json:"DetailGT"`
}

func (f PodTableDetailGTForm) Query(q *PodQuery) {
	if f.DetailGT != nil {
		q.Where(pod.DetailGT(*f.DetailGT))
	}
}

type PodTableDetailGTEForm struct {
	DetailGTE *string `form:"DetailGTE" json:"DetailGTE"`
}

func (f PodTableDetailGTEForm) Query(q *PodQuery) {
	if f.DetailGTE != nil {
		q.Where(pod.DetailGTE(*f.DetailGTE))
	}
}

type PodTableDetailLTForm struct {
	DetailLT *string `form:"DetailLT" json:"DetailLT"`
}

func (f PodTableDetailLTForm) Query(q *PodQuery) {
	if f.DetailLT != nil {
		q.Where(pod.DetailLT(*f.DetailLT))
	}
}

type PodTableDetailLTEForm struct {
	DetailLTE *string `form:"DetailLTE" json:"DetailLTE"`
}

func (f PodTableDetailLTEForm) Query(q *PodQuery) {
	if f.DetailLTE != nil {
		q.Where(pod.DetailLTE(*f.DetailLTE))
	}
}

type PodTableDetailContainsForm struct {
	DetailContains *string `form:"DetailContains" json:"DetailContains"`
}

func (f PodTableDetailContainsForm) Query(q *PodQuery) {
	if f.DetailContains != nil {
		q.Where(pod.DetailContains(*f.DetailContains))
	}
}

type PodTableDetailHasPrefixForm struct {
	DetailHasPrefix *string `form:"DetailHasPrefix" json:"DetailHasPrefix"`
}

func (f PodTableDetailHasPrefixForm) Query(q *PodQuery) {
	if f.DetailHasPrefix != nil {
		q.Where(pod.DetailHasPrefix(*f.DetailHasPrefix))
	}
}

type PodTableDetailHasSuffixForm struct {
	DetailHasSuffix *string `form:"DetailHasSuffix" json:"DetailHasSuffix"`
}

func (f PodTableDetailHasSuffixForm) Query(q *PodQuery) {
	if f.DetailHasSuffix != nil {
		q.Where(pod.DetailHasSuffix(*f.DetailHasSuffix))
	}
}

type PodTableDetailEqualFoldForm struct {
	DetailEqualFold *string `form:"DetailEqualFold" json:"DetailEqualFold"`
}

func (f PodTableDetailEqualFoldForm) Query(q *PodQuery) {
	if f.DetailEqualFold != nil {
		q.Where(pod.DetailEqualFold(*f.DetailEqualFold))
	}
}

type PodTableDetailContainsFoldForm struct {
	DetailContainsFold *string `form:"DetailContainsFold" json:"DetailContainsFold"`
}

func (f PodTableDetailContainsFoldForm) Query(q *PodQuery) {
	if f.DetailContainsFold != nil {
		q.Where(pod.DetailContainsFold(*f.DetailContainsFold))
	}
}

type PodTableCreatedAtEQForm struct {
	CreatedAtEQ *time.Time `form:"CreatedAtEQ" json:"CreatedAtEQ"`
}

func (f PodTableCreatedAtEQForm) Query(q *PodQuery) {
	if f.CreatedAtEQ != nil {
		q.Where(pod.CreatedAtEQ(*f.CreatedAtEQ))
	}
}

type PodTableCreatedAtNEQForm struct {
	CreatedAtNEQ *time.Time `form:"CreatedAtNEQ" json:"CreatedAtNEQ"`
}

func (f PodTableCreatedAtNEQForm) Query(q *PodQuery) {
	if f.CreatedAtNEQ != nil {
		q.Where(pod.CreatedAtNEQ(*f.CreatedAtNEQ))
	}
}

type PodTableCreatedAtInForm struct {
	CreatedAtIn *[]time.Time `form:"CreatedAtIn" json:"CreatedAtIn"`
}

func (f PodTableCreatedAtInForm) Query(q *PodQuery) {
	if f.CreatedAtIn != nil {
		q.Where(pod.CreatedAtIn(*f.CreatedAtIn...))
	}
}

type PodTableCreatedAtNotInForm struct {
	CreatedAtNotIn *[]time.Time `form:"CreatedAtNotIn" json:"CreatedAtNotIn"`
}

func (f PodTableCreatedAtNotInForm) Query(q *PodQuery) {
	if f.CreatedAtNotIn != nil {
		q.Where(pod.CreatedAtNotIn(*f.CreatedAtNotIn...))
	}
}

type PodTableCreatedAtGTForm struct {
	CreatedAtGT *time.Time `form:"CreatedAtGT" json:"CreatedAtGT"`
}

func (f PodTableCreatedAtGTForm) Query(q *PodQuery) {
	if f.CreatedAtGT != nil {
		q.Where(pod.CreatedAtGT(*f.CreatedAtGT))
	}
}

type PodTableCreatedAtGTEForm struct {
	CreatedAtGTE *time.Time `form:"CreatedAtGTE" json:"CreatedAtGTE"`
}

func (f PodTableCreatedAtGTEForm) Query(q *PodQuery) {
	if f.CreatedAtGTE != nil {
		q.Where(pod.CreatedAtGTE(*f.CreatedAtGTE))
	}
}

type PodTableCreatedAtLTForm struct {
	CreatedAtLT *time.Time `form:"CreatedAtLT" json:"CreatedAtLT"`
}

func (f PodTableCreatedAtLTForm) Query(q *PodQuery) {
	if f.CreatedAtLT != nil {
		q.Where(pod.CreatedAtLT(*f.CreatedAtLT))
	}
}

type PodTableCreatedAtLTEForm struct {
	CreatedAtLTE *time.Time `form:"CreatedAtLTE" json:"CreatedAtLTE"`
}

func (f PodTableCreatedAtLTEForm) Query(q *PodQuery) {
	if f.CreatedAtLTE != nil {
		q.Where(pod.CreatedAtLTE(*f.CreatedAtLTE))
	}
}

type PodTableUpdatedAtEQForm struct {
	UpdatedAtEQ *time.Time `form:"UpdatedAtEQ" json:"UpdatedAtEQ"`
}

func (f PodTableUpdatedAtEQForm) Query(q *PodQuery) {
	if f.UpdatedAtEQ != nil {
		q.Where(pod.UpdatedAtEQ(*f.UpdatedAtEQ))
	}
}

type PodTableUpdatedAtNEQForm struct {
	UpdatedAtNEQ *time.Time `form:"UpdatedAtNEQ" json:"UpdatedAtNEQ"`
}

func (f PodTableUpdatedAtNEQForm) Query(q *PodQuery) {
	if f.UpdatedAtNEQ != nil {
		q.Where(pod.UpdatedAtNEQ(*f.UpdatedAtNEQ))
	}
}

type PodTableUpdatedAtInForm struct {
	UpdatedAtIn *[]time.Time `form:"UpdatedAtIn" json:"UpdatedAtIn"`
}

func (f PodTableUpdatedAtInForm) Query(q *PodQuery) {
	if f.UpdatedAtIn != nil {
		q.Where(pod.UpdatedAtIn(*f.UpdatedAtIn...))
	}
}

type PodTableUpdatedAtNotInForm struct {
	UpdatedAtNotIn *[]time.Time `form:"UpdatedAtNotIn" json:"UpdatedAtNotIn"`
}

func (f PodTableUpdatedAtNotInForm) Query(q *PodQuery) {
	if f.UpdatedAtNotIn != nil {
		q.Where(pod.UpdatedAtNotIn(*f.UpdatedAtNotIn...))
	}
}

type PodTableUpdatedAtGTForm struct {
	UpdatedAtGT *time.Time `form:"UpdatedAtGT" json:"UpdatedAtGT"`
}

func (f PodTableUpdatedAtGTForm) Query(q *PodQuery) {
	if f.UpdatedAtGT != nil {
		q.Where(pod.UpdatedAtGT(*f.UpdatedAtGT))
	}
}

type PodTableUpdatedAtGTEForm struct {
	UpdatedAtGTE *time.Time `form:"UpdatedAtGTE" json:"UpdatedAtGTE"`
}

func (f PodTableUpdatedAtGTEForm) Query(q *PodQuery) {
	if f.UpdatedAtGTE != nil {
		q.Where(pod.UpdatedAtGTE(*f.UpdatedAtGTE))
	}
}

type PodTableUpdatedAtLTForm struct {
	UpdatedAtLT *time.Time `form:"UpdatedAtLT" json:"UpdatedAtLT"`
}

func (f PodTableUpdatedAtLTForm) Query(q *PodQuery) {
	if f.UpdatedAtLT != nil {
		q.Where(pod.UpdatedAtLT(*f.UpdatedAtLT))
	}
}

type PodTableUpdatedAtLTEForm struct {
	UpdatedAtLTE *time.Time `form:"UpdatedAtLTE" json:"UpdatedAtLTE"`
}

func (f PodTableUpdatedAtLTEForm) Query(q *PodQuery) {
	if f.UpdatedAtLTE != nil {
		q.Where(pod.UpdatedAtLTE(*f.UpdatedAtLTE))
	}
}

// PodGroupBy is the group-by builder for Pod entities.
type PodGroupBy struct {
	config
	fields []string
	fns    []AggregateFunc
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Aggregate adds the given aggregation functions to the group-by query.
func (pgb *PodGroupBy) Aggregate(fns ...AggregateFunc) *PodGroupBy {
	pgb.fns = append(pgb.fns, fns...)
	return pgb
}

// Scan applies the group-by query and scans the result into the given value.
func (pgb *PodGroupBy) Scan(ctx context.Context, v interface{}) error {
	query, err := pgb.path(ctx)
	if err != nil {
		return err
	}
	pgb.sql = query
	return pgb.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (pgb *PodGroupBy) ScanX(ctx context.Context, v interface{}) {
	if err := pgb.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from group-by.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) Strings(ctx context.Context) ([]string, error) {
	if len(pgb.fields) > 1 {
		return nil, errors.New("ent: PodGroupBy.Strings is not achievable when grouping more than 1 field")
	}
	var v []string
	if err := pgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (pgb *PodGroupBy) StringsX(ctx context.Context) []string {
	v, err := pgb.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = pgb.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodGroupBy.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (pgb *PodGroupBy) StringX(ctx context.Context) string {
	v, err := pgb.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from group-by.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) Ints(ctx context.Context) ([]int, error) {
	if len(pgb.fields) > 1 {
		return nil, errors.New("ent: PodGroupBy.Ints is not achievable when grouping more than 1 field")
	}
	var v []int
	if err := pgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (pgb *PodGroupBy) IntsX(ctx context.Context) []int {
	v, err := pgb.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = pgb.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodGroupBy.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (pgb *PodGroupBy) IntX(ctx context.Context) int {
	v, err := pgb.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from group-by.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) Float64s(ctx context.Context) ([]float64, error) {
	if len(pgb.fields) > 1 {
		return nil, errors.New("ent: PodGroupBy.Float64s is not achievable when grouping more than 1 field")
	}
	var v []float64
	if err := pgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (pgb *PodGroupBy) Float64sX(ctx context.Context) []float64 {
	v, err := pgb.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = pgb.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodGroupBy.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (pgb *PodGroupBy) Float64X(ctx context.Context) float64 {
	v, err := pgb.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from group-by.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) Bools(ctx context.Context) ([]bool, error) {
	if len(pgb.fields) > 1 {
		return nil, errors.New("ent: PodGroupBy.Bools is not achievable when grouping more than 1 field")
	}
	var v []bool
	if err := pgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (pgb *PodGroupBy) BoolsX(ctx context.Context) []bool {
	v, err := pgb.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (pgb *PodGroupBy) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = pgb.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodGroupBy.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (pgb *PodGroupBy) BoolX(ctx context.Context) bool {
	v, err := pgb.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (pgb *PodGroupBy) sqlScan(ctx context.Context, v interface{}) error {
	for _, f := range pgb.fields {
		if !pod.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("invalid field %q for group-by", f)}
		}
	}
	selector := pgb.sqlQuery()
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := pgb.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

func (pgb *PodGroupBy) sqlQuery() *sql.Selector {
	selector := pgb.sql.Select()
	aggregation := make([]string, 0, len(pgb.fns))
	for _, fn := range pgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	// If no columns were selected in a custom aggregation function, the default
	// selection is the fields used for "group-by", and the aggregation functions.
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(pgb.fields)+len(pgb.fns))
		for _, f := range pgb.fields {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	return selector.GroupBy(selector.Columns(pgb.fields...)...)
}

// PodSelect is the builder for selecting fields of Pod entities.
type PodSelect struct {
	*PodQuery
	// intermediate query (i.e. traversal path).
	sql *sql.Selector
}

// Scan applies the selector query and scans the result into the given value.
func (ps *PodSelect) Scan(ctx context.Context, v interface{}) error {
	if err := ps.prepareQuery(ctx); err != nil {
		return err
	}
	ps.sql = ps.PodQuery.sqlQuery(ctx)
	return ps.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (ps *PodSelect) ScanX(ctx context.Context, v interface{}) {
	if err := ps.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) Strings(ctx context.Context) ([]string, error) {
	if len(ps.fields) > 1 {
		return nil, errors.New("ent: PodSelect.Strings is not achievable when selecting more than 1 field")
	}
	var v []string
	if err := ps.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (ps *PodSelect) StringsX(ctx context.Context) []string {
	v, err := ps.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = ps.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodSelect.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (ps *PodSelect) StringX(ctx context.Context) string {
	v, err := ps.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) Ints(ctx context.Context) ([]int, error) {
	if len(ps.fields) > 1 {
		return nil, errors.New("ent: PodSelect.Ints is not achievable when selecting more than 1 field")
	}
	var v []int
	if err := ps.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (ps *PodSelect) IntsX(ctx context.Context) []int {
	v, err := ps.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = ps.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodSelect.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (ps *PodSelect) IntX(ctx context.Context) int {
	v, err := ps.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) Float64s(ctx context.Context) ([]float64, error) {
	if len(ps.fields) > 1 {
		return nil, errors.New("ent: PodSelect.Float64s is not achievable when selecting more than 1 field")
	}
	var v []float64
	if err := ps.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (ps *PodSelect) Float64sX(ctx context.Context) []float64 {
	v, err := ps.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = ps.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodSelect.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (ps *PodSelect) Float64X(ctx context.Context) float64 {
	v, err := ps.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) Bools(ctx context.Context) ([]bool, error) {
	if len(ps.fields) > 1 {
		return nil, errors.New("ent: PodSelect.Bools is not achievable when selecting more than 1 field")
	}
	var v []bool
	if err := ps.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (ps *PodSelect) BoolsX(ctx context.Context) []bool {
	v, err := ps.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (ps *PodSelect) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = ps.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{pod.Label}
	default:
		err = fmt.Errorf("ent: PodSelect.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (ps *PodSelect) BoolX(ctx context.Context) bool {
	v, err := ps.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (ps *PodSelect) sqlScan(ctx context.Context, v interface{}) error {
	rows := &sql.Rows{}
	query, args := ps.sql.Query()
	if err := ps.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}
